







When you use a path like assets/glbl-logo--light.svg in your HTML, the browser starts looking from the current document's location. This is called the "current working directory" in file system terms.



So if your index.html file and your assets folder are in the same directory, the browser will look for:



(current directory)/assets/glbl-logo--light.svg



These paths will work on both your local development environment and on GitHub Pages.









When you're working in a file that's in a different directory level, you need to navigate appropriately.

Let's visualize a project structure:



project-root/

  ├── index.html

  ├── assets/

  │     └── hero-image.png

  └── scss/

        └── styles.scss



From your styles.scss file, to reference files in the assets directory, you would indeed use ../assets/hero-image.png. The ../ means "go up one directory level" (to the project root), and then find the assets folder from there. So, in summary:



'./' or not writing anything at all means 'current directory', you're explicitly telling the browser to look in the current directory. For example <img src="./assets/hero-image.png"> would be functionally identical to <img src="assets/hero-image.png">.



'../' means 'parent directory'. This is incredibly useful when working with files in nested folders.



This is why relative paths are so named - they're relative to the current file's location, not to a fixed starting point.



Note: The same principle applies to page links - using relative paths instead of root-relative paths makes your links work correctly regardless of where your site is hosted.







In SCSS (and CSS), HTML attributes like 'disabled' or data-variants, are targeted with square brackets \[], not parentheses or semicolons. So for example:



  \&\[disabled] {

    opacity: 0.5;

    cursor: not-allowed;

  }





-\& acts as the parent selector reference, as you know.

-\[disabled] - Attribute selector targeting elements with the disabled attribute.









When using the Source Control feature on VS Code, and you are in the process of adding a comment to your commit:



1\. The first line (turning red) is reserved for the commit title/summary and typically has a character limit (often 50-72 characters, depending on configuration)

2\. The second line should be blank to separate the title from description

3.Lines after that can contain a more detailed description with no practical character limit











The hashtags (#) in Markdown (the files with an .md extension) represent headings, and they work on a hierarchy system:



\# (one hashtag) is a level 1 heading - the main title or H1 (biggest)

\## (two hashtags) is a level 2 heading or H2 (second biggest)

\### (three hashtags) is a level 3 heading or H3

And so on, up to ###### (six hashtags) for H6 (smallest heading)



The reason for adding an extra hashtag for each subsequent heading level is to create a logical document structure or outline









Here's what JSON.stringify does in simple terms:



JSON.stringify takes a JavaScript object and converts it into a text string in JSON format.

For example:



A JavaScript object like {name: "John", age: 30} becomes the string '{"name":"John","age":30}'

The object is now text that you can print, save to a file, or send over the internet



The optional parameters (like null, 2) just control how the resulting string looks:



-With JSON.stringify(obj): You get a compact string with no spaces or line breaks

-With JSON.stringify(obj, null, 2): You get a nicely formatted string with indentation and line breaks



This is especially useful for console logging because it shows you the complete object structure as text









If you are using any libraries from npm to build an application, it’s necessary to use some sort of bundler — like Webpack — to build your application and all of its dependencies. This requirement applies to many packages on npm. Using a CDN is also OK, if you’re more comfortable with that.







You can also use the multiple-values shortcuts in the padding-block and padding-inline properties, like this:



 padding-block: $space-2x $space-1x;

 padding-inline: $space-3x $space-2x;



The values assigned will be top-bottom and left-right, respectively









When you use inline styles on an HTML element (like a footer), those styles will only affect that specific instance of the element where the inline style is applied. This is because inline styles are applied directly to the individual HTML element using the style attribute.

For example, if you have the same footer component on multiple pages:



On Page 1: <footer>...</footer> (using standard CSS)

On Page 2: <footer style="background-color: blue;">...</footer> (with inline style)



The blue background will only appear on Page 2's footer. The Page 1 footer remains unchanged.

This is one advantage of inline styles for specific overrides - they have high specificity and only affect the exact element they're applied to.  This is also why inline styles are generally discouraged for common styling patterns and most cases, as they can't be reused easily and increase code duplication.



However, they can be perfectly fine for truly one-off changes that won't be repeated









When an image asset is loaded on the initial page visit, the browser will store it in its cache. Then, when a user navigates to other pages on your site that use the same image file (with the identical URL path), the browser will load it from the cache instead of downloading it again.



This provides several benefits:



-The image loads instantly on subsequent page views

-It reduces bandwidth usage for both your server and the user

-It improves page load performance on those subsequent views







:has() is another very powerful CSS selector that allows you to easily handle styling changes based on 'states' in your interface and other conditions. Mostly, it is a relational pseudo-class that tests whether an element contains another specified element inside it. Here're some common use cases for it:





1\. Parent Selection: Select a parent based on what's inside it



/\* Style any div that contains an image \*/

div:has(img) {

  padding: 1rem;

}



2\. Conditional Styling: Apply styles based on the presence of specific elements



/\* Style form fields that have an error message \*/

.form-field:has(.error-message) {

  border-color: red;

}



3\. State-Based Styling: Respond to element states in a parent-child relationship



/\* Style a card when its button is hovered \*/

.card:has(button:hover) {

  box-shadow: 0 0 10px rgba(0,0,0,0.2);

}



In our particular use case, we had to control to vertical distance of one group of elements whenever the navbar became visible, so the navbar would not cover the group of elements in question. So we used this:



/\* Adjust top position when navbar has is-scroll-up class, so navbar does not interfere with the faq categories \*/

body:has(.is-scroll-up) .faqs-categories {

  top: 6.5rem;

}



Basically, what we were telling the browser here is:



''"Target any .faqs-categories element that is a descendant of the body element, but only if that body element contains an element with the class 'is-scroll-up' somewhere inside it."



:has()  is a forward-looking selector (it looks at descendants or subsequent elements), and significantly expands what's possible with CSS alone, reducing the need for JavaScript to handle many styling adjustments based on content or state changes.









When creating a site with Cloudflare and assigning a custom domain, make sure that you uncheck the 'Proxy status' on the CNAME record. so the custom-domain.example.com CNAME example.pages.dev is set to unproxied (turning the orange cloud to gray). What this does is bypassing Cloudflare's proxy service for that specific record and create a direct connection between your custom domain and the Cloudflare Pages subdomain, eliminating the extra hop.









CORS (Cross-Origin Resource Sharing) is a security feature implemented by web browsers that controls how web pages in one domain can request resources from another domain. It's essentially a set of rules that browsers enforce to prevent potentially malicious websites from accessing data across different origins without permission.



When a web application tries to make a request to a server on a different domain (a "cross-origin request"), the browser first checks if that server has explicitly allowed such requests. If not, the browser blocks the request entirely to protect users from potential security vulnerabilities.



In the context of your chat app, think of CORS like international mail delivery:



1\. Your Vue app (in country A) wants to send a letter to the Anthropic API (in country B)

2\. Due to security concerns, you use a trusted intermediary (your Worker) in country C

3\. The security rules require that any mail coming from country C must have specific customs declarations (the CORS headers in the response body and the catch statement)

4\. If these declarations are missing, the mail is returned without being delivered, even if the contents were perfectly legitimate



The CORS headers are those customs declarations that must be included with every piece of mail (response), whether it contains good news or bad news.



Without CORS, any website could potentially:



-Make requests to your bank's API using your logged-in credentials

-Fetch private data from services where you're authenticated

-Send requests that might modify data on other domains



CORS was created to allow legitimate cross-origin communication while preventing these security risks. It works by requiring servers to explicitly declare which origins can access their resources, what HTTP methods can be used, and what headers can be included.







JavaScript is a language, Node.js is the environment where that language runs. It's similar to how you might write a letter in English, but you could read that letter in your living room, in a library, or in a coffee shop - same language, different environments.



Node.js serves as the execution environment that gives your JavaScript code access to capabilities that browsers don't have. Think of Node.js as providing a different set of "superpowers" to your JavaScript code. In a browser, your JavaScript can manipulate web pages and make HTTP requests, but it's sandboxed for security. Node.js removes those restrictions and adds new capabilities like file system access, process control, and the ability to run other programs.



So at its core, you're still writing pure JavaScript. Node.js doesn't change the language - it expands what that language can do.





In software development, "headless" means that a program or application runs without a graphical user interface (GUI), often used for tasks where a user interface isn't necessary or desirable, such as servers or headless browsers.







In VS Code's terminal, use the command cd ~/Desktop to navigate directly to your home directory.

To set up a new folder there, use the command mkdir + name of the project (e.g 'mkdir job-scraper')

To move again to that folder and start installing all the files, use 'cd' again (e.g 'cd job-scraper')

You can then start creating folders inside the project folder using mkdir again, one at a time (e.g 'mkdir frontend' or 'mkdir backend')



If you need to create a particular file rather than a folder, you can use the 'ni' command (e.g 'ni server.js'). 'ni' is an alias for 'New-Item'









When setting up a server and using GET methods, the below function defines what happens when someone visits the URL you create:



app.get('/your-path', (req, res) => {

    // First parameter 'req' process the request

    // 'res' send back a response

});



'/your-path' becomes part of your URL after the server name (e.g 'http://localhost:3001/hello-world'), while req processes the request and res sends back a response (often a JSON string, for which we have to use the '.json' method).



See below a complete example:



app.get('/hello-world', (req, res) => {

    res.json({

        message: 'Hello from hello-world!',

        timestamp: new Date().toISOString(),

        status: 'healthy'

    });

});



Unlike POST endpoints, which require a formatted request, you can visit these URLs directly and get information straight away.









POST endpoints (like your /api/scrape-jobs) are like service counters - you need to approach them with specific information and make a formal request. You can't just "visit" them in a browser because browsers don't know what data to send. It's like walking up to a custom sandwich shop - they can't make your sandwich until you tell them what ingredients you want.



The POST endpoint is waiting for someone to contact it with specific parameters (like {"jobTitle": "frontend developer", "location": "remote"}), but without that data, it can't do anything useful nor display anything.









When installing a project from GitHub through the terminal, sometimes you might get yellow warnings about other packages being uninstalled. This means that the program uses a different (likely more updated) version of those programs, so it is uninstalling them for you and reinstalling the correct version. You do not have to do anything about these warnings.





Python installs packages globally (or in your Python environment) in a central location on your system. The packages are stored in Python's site-packages directory, not in your project folder. Based on your earlier installation output, packages are installed in: C:\\Users\\migue\\AppData\\Roaming\\Python\\Python312\\Scripts.



You can find if a package/program has been properly installed by running this command in your terminal:



pip list | findstr name-of-package









To create a new branch both locally and on your GitHub repo, use the following command on the terminal:



 git checkout -b your-branch-name



And then click on 'Publish Branch' in the Source Control panel.







You can add text to pseudo-elements by using the attr property as shown below



.showcase-card\_\_info {



  \&::after {

            content: attr(data-collection-date);

}



}



You would have to actually add said attribute to the HTML tag with the data you want to use for it to work:



                    <div class="showcase-card\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_info" data-collection-date="November 2024">



This would display text inside the pseudo-element rather than make it empty, as they usually are.









width: auto is generally ideal for responsive images when you're controlling the size with height:



-Maintains aspect ratio - the image scales proportionally based on the height

-Prevents distortion - width adjusts automatically to match the height constraint

-Respects max-width - won't exceed max-width property even if the height would make it larger

-Performance - browser doesn't have to calculate conflicting width/height constraints









CSS Grid with auto-fit and minmax() is the most powerful combination for responsive layouts. Using repeat(), auto-fit and minmax() creates layouts without any media queries, adapting to the available screen real state. So let's take the below property as an example:



grid-template-columns: repeat(auto-fit, minmax(500px, 1fr));



The repeat() function is a shorthand that saves you from writing the same column definition over and over. Instead of writing 1fr 1fr 1fr 1fr for four equal columns, you can write repeat(4, 1fr). The first parameter is how many times to repeat, and the second is what to repeat.



But here's where it gets interesting - instead of a fixed number like 4, you're using auto-fit, which means "create as many columns as will fit based on the constraints I'm about to give you."



The minmax(500px, 1fr) part defines the size range for each column. Think of it as setting boundaries:



-Minimum size: 500px - Each column will never be smaller than 500 pixels wide

-Maximum size: 1fr - Each column can grow to take up its fair share of available space (the fr unit means "fractional unit" - it divides remaining space proportionally)



So if your container is 1200px wide, you could fit two columns at 600px each (since 600px > 500px minimum). If your container is 1800px wide, you could fit three columns at 600px each, and so on.



auto-fit is the responsive magic maker. auto-fit tells the grid system: "Create as many columns as will fit given the minimum size constraint, and if there are fewer items than columns, let the existing columns grow to fill the space."





When the browser has less than 500px of available width, the 500px minimum is treated more like a strong suggestion than an absolute rule, so it creates one column and allows it to be smaller than the specified minimum.









The clamp() CSS function clamps a middle value within a range of values between a defined minimum bound and a maximum bound



The syntax: clamp(minimum, preferred, maximum)



How it works in plain English:



-Browser tries to use the "preferred" value

-If preferred is too small, use minimum

-If preferred is too large, use maximum

-It has the same effect as fluid typography but in one line, and without the use of media queries







There are some elements and properties that can help you handle large words and text content more easily on smaller viewports:



-You can add the <wbr> HTML tag into any word, this will make it break at the point you set the tag.

-The word-break CSS property sets whether line breaks appear wherever the text would otherwise overflow its content box. word-break: break-all; will make each line end of text end exactly at the edge, even if it has to split a word into two lines.







flex: 1 is shorthand for:



-flex-grow: 1 - Can grow to fill available space

-flex-shrink: 1 - Can shrink if needed

-flex-basis: 0 - Starting size is 0



Here's how the flex property (in this case, flex: 1) can be used to distribute spacing smartly and responsively:



┌─────────────────┐

│ artwork-header  │ ← Takes only content height

├─────────────────┤

│                 │

│ artwork-bio     │ ← GROWS to fill all available space with flex: 1

│                 │

│                 │

├─────────────────┤

│ saatchi-button  │ ← Gets pushed to bottom





flex: 1 tells a flex item: "Take up all the leftover space." So if you have 3 items in a container and only one has flex: 1, that item will expand to consume whatever space the other two don't use, effectively pushing everything else to the edges or bottom.







Whenever you duplicate content purely for visual effects (like animations, decorative elements, or UI enhancements), you should hide the duplicates from assistive technologies using aria-hidden="true"







If a certain design does not scale well, no matter what you try, don't be so stubborn and experiment with a different approach. Look for the simplest solution and don't try to adapt your entire website or navigation, but rather adapt the part that's being problematic. This advice applies particularly to hero sections.







The \&nbsp; (non-breaking space) is an HTML entity that prevents the browser from inserting a line break at that specific point.



<h1>

  We turn raw data into measurable

  <span class="highlight">business\&nbsp;growth</span>

  and key insights

</h1>



So even when the text needs to wrap, "business" and "growth" will always stay together as one unit. So use \&nbsp where you want to completely prevent a line break at a specific point, but don't abuse it or your lines might end up splitting at odd points.







The \& symbol after a class name in CSS, is a powerful selector that is particularly useful when dealing with media queries and responsive content. See an example:



.hero\_\_title {

    // Base styles for desktop

 

    .hero\_\_content--mobile \& {

        // Styles when .hero\_\_title is INSIDE .hero\_\_content--mobile

    }

}



The \& symbol represents the parent selector in SCSS. When you write .hero\_\_content--mobile \&, it compiles to:



.hero\_\_content--mobile .hero\_\_title



This means: "Apply these styles to .hero\_\_title only when it's inside .hero\_\_content--mobile"



So the \& lets us write nested styles that target the current element when it's in a specific context, rather than targeting a child element.







When using absolute positioning, setting all the 4 positional parameters to 0 makes the element take up the entire section or element parenting the absolute positioned element:



.hero\_\_content--mobile {

    position: absolute;

    top: 0; left: 0; right: 0; bottom: 0;  // This makes it fill the entire hero section

    width: 100%;

    height: 100%;

}







If you are working with height-sensitive designs, use a combination of these three properties to get a flexible element that will scale well in most viewports:



-aspect-ratio

-min-height

-height: auto



With height: auto, the browser calculates the height automatically using this formula:



height = width ÷ aspect-ratio



As the viewport width changes, the browser instantly recalculates the height to maintain your specified ratio









CSS Specificity Rules (in order of priority):



-Inline styles (style="height: 500px") - HIGHEST PRIORITY

-IDs (#myElement { height: 400px })

-Classes (.columns-wrapper { height: 300px })

-General Elements (div { height: 200px })



What this means:



-When JavaScript sets columnsWrapper.style.height = '500px', it creates an inline style

-Inline styles always override CSS rules, regardless of specificity

-So even if your CSS has .columns-wrapper { height: 69.5vh !important }, the JavaScript value wins







If you ever need to block a GSAP animation or any other JavaScript logic from running under certain conditions (e.g only run GSAP animation above a certain viewport size), you can wrap everything inside an IF statement if you want a quick fix that will ensure your code works where it's supposed to.



See the below example based on the directory animation from The Hundred homepage:



<script>

\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\&nbsp;   if (window.innerWidth >= 1024) {

\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\&nbsp;       // 1. Register plugins first

\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\&nbsp;       gsap.registerPlugin(ScrollTrigger);

\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\&nbsp;       

\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\&nbsp;       // 2. Define your functions/classes

\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\&nbsp;       function directoryReveal() {

\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\&nbsp;           // your animation code

\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\&nbsp;       }

\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\&nbsp;       

\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\&nbsp;       class HorizontalCarousel {

\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\&nbsp;           // your class code

\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\&nbsp;       }

\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\&nbsp;       

\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\&nbsp;       // 3. Initialize when DOM is ready (at the end)

\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\&nbsp;       document.addEventListener('DOMContentLoaded', () => {

\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\&nbsp;           directoryReveal();

\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\&nbsp;           // or: new HorizontalCarousel();

\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\&nbsp;       });

\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\&nbsp;   }










The dvh (dynamic viewport height) CSS unit represents 1% of the currently visible viewport height, dynamically adjusting to changes such as the appearance or disappearance of browser UI elements (e.g., address bars, toolbars, on-screen keyboards) on mobile and tablet devices.



How dvh Works Exactly



-Unlike the traditional vh unit, which often corresponds to the viewport height including hidden or visible browser UI (and can cause layout issues on mobile), dvh reflects the actual visible height at any moment.



-It automatically switches between the "large viewport height" (lvh) when UI controls are hidden and the "small viewport height" (svh) when UI controls are visible, providing a smooth, dynamic measurement of the viewport height.



-For example, 100dvh means the element’s height will always match 100% of the visible viewport height regardless of whether browser UI is shown or hidden.







max-width, as a strategic constraint rather than a heavy-handed rule, it's pretty convenient when dealing with media queries. Here's why:



/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\* Bad: Fighting the browser at every breakpoint \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/

.element {

  width: 100%;

 

  @media (max-width: 768px) {

    width: 90%;

  }

 

  @media (max-width: 480px) {

    width: 95%;

  }

}



/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\* Good: Set boundaries, let content flow naturally \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/

.element {

  max-width: 600px; // "Never get wider than this"

  width: 100%;      // "But use available space up to that limit"

}



Set upper boundaries where things break down (readability, layout, UX), but let elements shrink naturally below that point. Essentially, by setting a carefully chosen max-width on the parent container, you're saving yourself from a lot of work and manual changes for the children inside of it.







You will often encounter issues with overflowing Fixed/Floating content on devices with very limited width, such as a mobile viewport on landscape mode. The trick is to enable scrolling so the user can see the whole content freely and you will not need media queries to work around a viewport with very limited vertical real state, which can be pretty problematic.



When fixed or floating elements (like nav menus) overflow on mobile landscape viewports, add these properties to the container holding the overflowing content to make it scrollable and fix the issue:



@media (max-height: 451px) and (orientation: landscape) {

  height: 300px;

  overflow-y: scroll;

  -webkit-overflow-scrolling: touch; /\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\* iOS smooth scrolling \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/

}



A defined height is essential—without it, browsers won't enable scrolling and content will simply overflow the viewport.









The key idea of designing web apps or web pages with Vue, is that you have two levels of styling: the container level (where you control overall layout, spacing between major sections, and page-wide responsive behavior) and the component level (where each component handles its own internal layout and styling).



When it comes to responsiveness, you have multiple approaches, and the best strategy combines them:



-Component-Level Responsiveness: Each component handles its own responsive behavior. Your ProjectCard.vue component would contain media queries for how project cards should behave on different screen sizes.



-Container-Level Responsiveness: Your view or layout components handle overall page structure changes. For example, your ProjectsSection.vue might change from a three-column grid to a single column on mobile.



Here's how this works in practice:



<!-- ProjectCard.vue -->

<style scoped>

.project-card {

\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\&nbsp; /\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\* Base styles \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/

\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\&nbsp; padding: var(--spacing-lg);

\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\&nbsp; border-radius: var(--radius-md);

}



@media (max-width: 768px) {

\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\&nbsp; .project-card {

\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\&nbsp;   padding: var(--spacing-md);

\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\&nbsp;   /\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\* Component-specific mobile adjustments \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/

\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\&nbsp; }

}






<!-- ProjectsSection.vue -->

<style scoped>

.projects-grid {

\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\&nbsp; display: grid;

\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\&nbsp; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));

\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\&nbsp; gap: var(--spacing-xl);

}



@media (max-width: 768px) {

\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\&nbsp; .projects-grid {

\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\&nbsp;   grid-template-columns: 1fr;

\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\&nbsp;   gap: var(--spacing-lg);

\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\&nbsp; }

}




To manage global CSS styles and variables, here's the most effective approach:



-Global Styles Setup: Create a styles/main.css file that contains your CSS custom properties, reset styles, and utility classes. Import this in your main.js file so it's available throughout your entire application.



-Component-Specific Styles: Each component uses <style scoped> for its specific styling needs, pulling from your global variables for consistency but adding component-specific rules.



In general, your components become like a design system for your own website. The ProjectCard component you create now can be reused if you later add a dedicated projects page. Your HeroSection might evolve into a more generic PageHeader component that you can customize for different pages.



The scoped styling ensures that each component's styles don't interfere with others, while your global variables maintain visual consistency. This gives you the best of both worlds: the modularity and organization of component-based development with the design control you need for a polished portfolio website.







It is better not to risk it with animations: if you do not know what to add or how to add it, just leave it as it is until you find another solution.







When using TypeScript in Vue, 'could not find errors' might occur because Vue's TypeScript support needs to understand that .vue files are valid modules. TypeScript is statically typed and needs to know the type of every import at compile time. 



Make sure you have a env.d.ts file (or similar) in your src directory with Vue type declarations:



<reference types="vite/client" />


declare module '\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*.vue' {

\\\\\\\\\\\\\\\&nbsp; import type { DefineComponent } from 'vue'

\\\\\\\\\\\\\\\&nbsp; const component: DefineComponent<{}, {}, any>

\\\\\\\\\\\\\\\&nbsp; export default component

}





The code above in your 'env.d.ts' should fix any 'could not find' problems you might see. The declaration 'declare module '\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*.vue' essentially tells TypeScript: "Any file ending in .vue exports a Vue component of this specific type."





A composable is a separate JavaScript file that exports a function containing reactive logic.



src/

├── composables/

│   └── useElevenLabs.js    // New composable file

├── components/

│   └── Menu.vue            // Your existing component

└── stores/

\\\\\\\&nbsp;   └── conversation.js     // Pinia store



-The composable is a separate .js file that you import into your component

-It's not injected - you call it as a function that returns reactive references and methods

-Multiple components can use the same composable independently

-The composable maintains its own internal state but can interact with Pinia stores





Vue 3 components, even though they have .vue extensions, are actually JavaScript under the hood. Everything inside <script setup> is regular JavaScript




The html element automatically inherits the body's background properties, which explains some of the background clipping issues you experienced on SPAs when the content you paste on a page is not enough to cover the entire viewport. 

Here's what happens in more detail:

-HTML element starts transparent: By default, the html element has background-color: transparent and background-image: none



-Automatic propagation occurs: When the HTML element has no background, browsers automatically copy (propagate) the background from the body element to the html element



When your body doesn't fill the viewport (no min-height: 100vh):



-Your background (gradient in this case, since we're talking about my portfolio website) gets propagated to the html element (which covers the full viewport)



-The body keeps a "copy" of the gradient but only covers its content area



-You see the gradient twice: once on the content-sized body, once on the full-viewport html


Keep in mind that by default, the body element has height: auto, which means it's only as tall as the content inside it and it does not automatically fill the viewport height.



So, when it comes to SPAs and background clipping due to insufficient content, the only true solutions are either setting a min-height: 100vh to the body element or making sure that the contents of a page at the very least cover the entire viewport height







v-html is what you used in Vue when you intend to render HTML elements into the code, rather than strings of text which is the Vue default. This is what you need to use when you need, for example, to dynamically render SVGs into a component.



\&nbsp; - Text interpolation {{ }} = "Show this as text"

\&nbsp; - HTML directive v-html = "Render this as HTML"



See it in practice below:



<span class="icon">{{ option.icon }}</span>

-Result: Literal text <svg xmlns="http://www.w3.org/2000/svg"... displayed

\&nbsp; on screen

\&nbsp; - Problem: Vue's {{ }} treats everything as text, not HTML





\&nbsp;<span class="icon" v-html="option.icon"></span>

\&nbsp; - Result: Actual SVG icon renders visually

\&nbsp; - Solution: Vue's v-html directive interprets the string as HTML markup



Regarding <a> elements, when you write href="www.linkedin.com", the browser treats it as a relative path from your current domain rather than an external link. You are missing the https:// protocol.

Here's how you should do it:

<a href="https://www.linkedin.com/in/your-profile-name">

or use protocol-relative URL

<a href="//www.linkedin.com/in/your-profile-name">


Use <figure> for logos, since that's the actual meaning of the figure tag: visual elements with some meaning. 




When building API-calling functions, the || fallbacks only work if the API call succeeds but returns incomplete data.But if the entire API call fails (network error, 404, authentication failure, etc.), you never get an object at all. Without the catch block, a failed API call would make that promise resolve to undefined, and you'd get:

voices.value = [validVoiceObject, undefined, validVoiceObject]

The catch block ensures that even complete API failures still contribute a usable object:

voices.value = [validVoiceObject, fallbackVoiceObject, validVoiceObject]

So you have two layers of fallbacks:

Property-level fallbacks (|| operators) for incomplete but successful responses
Object-level fallbacks (catch block) for complete API failures



You aren't gonna need it" (YAGNI) is a principle which arose from extreme programming (XP) that states a programmer should not add functionality until deemed necessary. Ron Jeffries, a co-founder of XP, explained the philosophy: "Always implement things when you actually need them, never when you just foresee that you [will] need them."




Don't overdo code optimization with Claude Code. If you run optimization prompts several times in a row, you'll end up running your logic into the ground and the code will eventually stop working, because Claude will overengineer the shit out of it once it runs out of sensible and reasonable improvement suggestions (which usually happens after the 2nd or even 1st round of optimizations). 

From now on, do not do more than 2 optimization runs, and if it still works, just let it be. 



A composable in Vue is a function that encapsulates and reuses stateful logic. It uses Vue's Composition API (like ref, reactive, computed) to manage reactive state and return it for use in components

Key differences from Pinia stores:

-Scope: Composables create isolated instances per component that uses them. Pinia stores are global singletons shared across the entire app.
-State sharing: Each component gets its own composable state. Pinia stores share state between all components.
-Persistence: Composable state is tied to component lifecycle. Store state persists until explicitly cleared.



In JavaScript, the fetch() function by default makes a GET request - that's actually the default HTTP method when you don't specify one explicitly. The fetch API assumes GET requests when you don't provide a method, since GET is the most common HTTP operation (it's what happens when you type a URL in your browser). We only need to explicitly specify the method when we're doing something else (e.g POST or PUT requests)


When you create a class in JavaScript, you often don't use that directly, but rather make an instance of it that you store on a regular variable: 

//Class creation
class TranscriptionImprover {
  constructor() { 

//Class instance
const transcriptionImprover = new TranscriptionImprover()

This design pattern is called dependency injection - instead of creating a new TranscriptionImprover every time you need to improve text, you create it once and reuse it. This is more efficient and ensures consistent behavior across all transcription sessions. The instance stays alive for the entire lifetime of your application, ready to be called whenever transcribeAudio() needs to improve some text.




Whether you're making a GET request to fetch data, a POST request to create something, a PUT request to update something, or a DELETE request to remove something, you always get a response back that tells you what happened and potentially gives you new data.
Even when you make a POST request to create something, the server often sends back the created item with additional fields (like an auto-generated ID or timestamp) that weren't in your original request.




You can use the following command to kickstart a conversation with Claude to work on the project you're currently on:

claude --resume

This will basically save you the step of telling Claude to analyze your codebase to get on context, since it will tell Claude Code to do it automatically and it will also check your commit history to see what you've been working on recently. It will essentially get Claude ready to work on whatever feature you want straight away




 In JavaScript classes, if a constructor doesn't do anything, you can actually omit it entirely. The constructor is only needed when you're initializing instance properties (like prompt templates in other services)



Start using the Windows Key + V shortcut with pinned clipping to save prompts you often reuse, so you don't have to write them over and over again. 


The = null is JavaScript's way of providing a default parameter value, which serves a similar purpose to TypeScript's optional parameters. See the below example from your speech-to-text app:

async transcribe(audioFile, apiKey, contextPrompt = null) {
  // If contextPrompt is not passed, it defaults to null
}

This means the function can be called in multiple ways:

// With context
transcribe(audioFile, apiKey, 'coding')     // contextPrompt = 'coding'

// Without context  
transcribe(audioFile, apiKey)               // contextPrompt = null (default)

// Explicitly null
transcribe(audioFile, apiKey, null)         // contextPrompt = null

the = null is essentially JavaScript's way of saying "this parameter is optional, and if not provided, treat it as null" - which perfectly handles cases where a parameter is completely optional and might not be provided, so the function can run regardless of that.


when using dynamic src attributes with v-bind (:src), the @ alias might not be resolved properly at runtime. The @ alias works fine for static imports in <script> sections or static src attributes in templates, but when the path is stored in a variable and          used dynamically, it might not resolve correctly. So for example, the below will not work:

<img :src="skill.icon" />

The solution is to import all the assets you're going to be serving in the component directly in the script section:

import pythonIcon from '@/assets/icons/python.svg'
import nodejsIcon from '@/assets/icons/nodejs.svg'
import fastapiIcon from '@/assets/icons/FastAPI.svg'

And then you link them to the attribute:

const skillCategories = {
  'Tech Stack': [
    { name: 'Vue 3', icon: vueIcon },
    { name: 'Python', icon: pythonIcon },
    { name: 'Node.js', icon: nodejsIcon },
    { name: 'FastAPI', icon: fastapiIcon },
    { name: 'JavaScript', icon: javascriptIcon }
  ],
//Rest of the icons and attributes

Then you can use this successfully:

<img :src="skill.icon">



To completely uninstall a package and revert all changes:

  1. Discard all file changes in Source Control (which you've already done)
  2. Remove the package by running:
  npm uninstall @package-name

Alternatively, since Git source control should already revert the package.json, you      can simply run:

  npm install

This will reinstall dependencies based on the reverted package.json, effectively        
removing the @formkit/auto-animate package.



FOUC (Flash of Unstyled Content) is this issue where a web page appears briefly with the browser's default styles prior to loading an external CSS stylesheet or an animation library (e.g GSAP), due to the web browser engine rendering the page before all information is retrieved.



If your LLM ever suggests using 'setTimeout' to fix an issue, take it with skepticism, as that rarely works.




After cloning a project removing the git history, you need to install the dependencies again by running 'npm install'. Here's the full process step by step (step 0 being situated already in the folder or desktop where you want to install your new project) 

# 1. Clone the repository
git clone https://github.com/username/repository-name.git your-new-project-name

# 2. Navigate to the project
cd your-new-project-name

# 3. Remove git history
Remove-Item -Recurse -Force .git

# 4. Install dependencies (THIS IS THE MISSING STEP!)
npm install

# 5. Initialize fresh git
git init
git add .
git commit -m "Initial commit"

# 6. Now you can run the project
npm run dev




Whenever you have a problem aligning an icon with a title (within a flex container), like the two elements do not seem aligned at all or the icon is slightly higher, try setting the display: block property to the SVG/IMG element.  SVGs often eed additional styling to align properly with text in a flex container, so this ensures the SVG renders as a block element. 

Any slight unalignments you might have after that, they can be fixed with some small negative margin values. 



When you install packages via npm on a feature branch, the packages themselves are not exclusive to that branch, meaning that while the package.json changes are branch-specific, the actual package files are added to the shared node_modules/ folder. 

After switching branches, run npm install to ensure your node_modules/ matches that branch's package.json. 

Running npm install on your main branch will:

-Install all packages listed in package.json that aren't already in node_modules/
-Remove any extra packages that exist in node_modules/ but aren't declared in package.json
-Restore the exact state defined by your package-lock.json



package.json is where you check your direct dependencies - the packages your app is actually using.

package-lock.json contains the complete dependency tree, including all the sub-dependencies (dependencies of your dependencies). For example, when you install vue, it might depend on 20 other packages - those all get listed in the lock file.

To check what's actually installed:

1. package.json = "What I directly need"
2. package-lock.json = "Everything that's actually installed (including sub-dependencies)"
3. node_modules/ = "What's physically on disk right now"

Keep in mind that Vite (and most modern bundlers) will treeshake unused code during production builds, but this works at the code level, not the package level. To see your actual bundle size: Run npm run build and check the output - Vite will show you exactly what's included and the final bundle sizes. Vite protects you from unused code, but keeping your package.json clean (like yours) is still the best practice.



In Pinia, each store maintains its own isolated state, so having a status variable in multiple stores will not cause any conflicts. This is actually one of the key benefits of using a state management library like Pinia - each store operates as its own independent module.



The ? (Optional Chaining Operator)

The ? in persona?.icon is called the optional chaining operator. It's a safety
feature that prevents errors when accessing properties of potentially undefined
objects.

What it does:
  - If persona exists → access persona.icon
  - If persona is null or undefined → return undefined instead of throwing an error        

Why we need it:

Since persona is computed from a store lookup, there's a brief moment during loading     
where it might be undefined. Without ?, you'd get an error like "Cannot read
property 'icon' of undefined".

  Example:
  // Without optional chaining (dangerous):
  persona.icon // ❌ Error if persona is undefined

  // With optional chaining (safe):
  persona?.icon // ✅ Returns undefined safely if persona is undefined



If you ever want to DISCARD all changes in Git (before they're commited obviously), run these two commands in that exact order:

git reset --hard HEAD
git clean -fd

git reset will remove all staged changes, discard all modifications to tracked files and reset your working directory to exactly match the last commit, while git clean removes any untracked file (new files you created during the working session you want to erase that have not been added to Git)



Use the below command to successfully add Context7 MCP to Claude Code for any project:

claude mcp add context7 -- npx @upstash/context7-mcp@latest



Use the below command to allow Claude Code to do everything he wants without asking permission

claude --dangerously-skip-permissions

Or add this to your settings.local.json file:

{
  "permissions": {
    "allow": [],
    "deny": [],
    "ask": [],
    "defaultMode": "bypassPermissions"
  }
}



Press Alt + M to switch to Plan Mode on Claude Code



If you type document.designMode = "on"; into the Chrome devtools, it lets you modify the text on the webpage directly.




The transform property creates a new stacking context when an animation is activated, so the element being animated it’s promoted to its own layer and paints above siblings that don’t set an explicit stacking order. This might affect other pseudo-elements in the main element that have no z-index, as the scaled content covers it during the animation, hiding the pseudo-element. 

This happens very often when scaling graphic content and having a pseudo-element in the parent container that acts as a border.


If in the future, you want to add Serena again to your Claude Code configuration, simply add this to your .claude.json file at the /migue directory:

 "mcpServers": {
    "serena": {
      "command": "uvx",
      "args": [
        "--from",
        "git+https://github.com/oraios/serena",
        "serena-mcp-server"
      ]
    }
  },



The 'ni' command is used to create new files inside an existing folder. 

ni src/__init__.py

Keep in mind that it requires the 'src' folder to actually exist. 




You can configure patterns to hide files and folders from the explorer and searches.

1. Open Visual Studio Code User Settings (Main menu: File → Preferences → Settings). This will open the setting screen.

2. Search for files:exclude in the search at the top.

3.Add the type of file you wish to hide. 




BaseIOSchema in Atomic Agents is just a thin wrapper around BaseModel, probably looking like this:

class BaseIOSchema(BaseModel):
    pass



When you want you just want an explanation on a code file or a portion of your codebase, without having a lot of code examples or additional actions from Claude, use the 'Explanatory' style. This will make the LLMs answer mostly text-based.  



It takes way longer than you think to reach context limits in Claude conversations. Whenever you think you're approaching it, simply ask how many tokens have you consumed so far and how much you got left, and Claude will tell you. 



In Vue, scoped styles in parent components (meaning components that hold other components) are NOT be accessible to child components due to Vue's scoping mechanism.



<RouterLink> renders as an <a> tag by default, which maintains semantic HTML and ensures accessibility for screen readers and keyboard navigation. Do not wrapping <button> or <a> inside <RouterLink> tags as this is incorrect. 



Embedding is a mathematical concept that refers to placing one object into a different space.



In OpenAI, the frequency penalty is a parameter that reduces the likelihood of the model repeating the same words or tokens within a single generated output by decreasing a word's score each time it's used. It helps promote vocabulary diversity and makes the text less repetitive. The parameter can be adjusted in the API, typically between -2.0 and 2.0, where a value of 0 means no penalty is applied.



When you define a variable and assign its value to an existing function, the return value of that function gets stored in the variable.

See the below variable, and assume there's a previously defined function called 'splitDocument' that returns something:

  const chunkData = await splitDocument("movies.txt"); 

Here, in our example:

1. splitDocument("movies.txt") returns the output variable (which contains the split document chunks)
2. That returned value is what gets stored in chunkData
3. You can then get chunkData somewhere else (e.g inside yet another function or a class)



In TypeScript, interface is not an object or variable—it's a special keyword used to define the shape (structure) of an object type. An interface lets you describe what properties and methods an object must have.


interface Person {
  name: string;
  age: number;
}

const user: Person = {
  name: "Alice",
  age: 30
};


'interface' is for describing object types, not for creating objects or variables. When you see interface in TypeScript, think of it as a blueprint or contract for the structure of objects, not as an object or variable itself.

interface Car {
  make: string;
  model: string;
}
let myCar: Car = { make: "Toyota", model: "Corolla" };


There's also something pretty similar called aliases, which are used for complex types in general.  
You can make them using the 'type' keyword:

type Point = { x: number; y: number };
let position: Point = { x: 1, y: 2 };




TypeScript also has a special type, any, that you can use whenever you don’t want a particular value to cause typechecking errors. When a value is of type any, you can access any properties of it (which will in turn be of type any), call it like a function, assign it to (or from) a value of any type, or pretty much anything else that’s syntactically legal. 

Using `any` disables all further type checking, and it is assumed you know the environment better than TypeScript.



For variables holding simple values, let TypeScript infer the types for you instead of using type annotations:

let x: number = 5;   // Correct but unnecessary 
let y = 10;	     // Inferred as number, still correct and shorter



In TypeScript it comes to Object Types, you can use the ? symbol to make a property optional:

let pet: { name: string; age?: number } = {
  name: "Buddy"
};



In TypeScript, you can allow a value to be one of several types using Union Types:

let id: number | string;
id = 42;
id = "A001"; // both fine

And with Literal Types, you can restrict the value of a variable to really specific values:

let direction: "left" | "right" | "center";
direction = "left"; // Only allowed values



By default in TypeScript null and undefined can be assigned to most types. They signal can that a variable intentionally has "no value." For example, an unfinished computation or an unset configuration options:

let result: number | null = null; // result is absent now, will be set later


Functions and objects can have optional parameters or properties, which are undefined until set

function greet(name?: string) {
  // name is undefined if not provided
  return "Hello, " + (name ?? "Guest");
}

Additionally, many APIs return null/undefined to indicate not found or missing. Using these values matches common patterns:

function findUser(id: string): User | undefined {
  // return undefined if user not found
}

So, in summary, assigning null or undefined lets you clearly express "no value" or "not set yet," making your code safer, more readable, and easier to maintain




NPM is a package management that is used to install, uninstall, and update Javascript packages on your workstation, whereas NPX is a package executer that is used to directly execute Javascript packages without installing them



When verbatimModuleSyntax is enabled, TypeScript requires you to be explicit about whether you're importing:

-Values (functions, classes, objects) - used at runtime
-Types (interfaces, type aliases) - only used for type checking, stripped away at build time



In Tailwind, if you want the text inside a card-like container to break lines at a certain point (before the end of the card/container), use the property w-value/value

This is a way to tell Tailwind "I want this element to have a width of X% of the parent element". 

And you'll likely want to use this for the longer breakpoints where text looks odd when it goes on for you long, so you'll use a property like this:

lg:w-3/4



Remember about z-index management when creating components. 
Here's how z-index should typically be organized:

z-0    = Default layer (overlays, backgrounds)
z-10   = Content layer (hero content)
z-40   = Dropdowns, popovers
z-50   = Navigation bars, headers
z-[100] = Modals, dialogs

So any dynamic content that 'opens up' after a user action (e.g a dropdown menu, a modal, mobile navigation that takes up most of the screen), should have the highest possible z-index, since this content has to be seen above everything else.



If you want to use the container class for consistency, but fix the problem where layouts in md viewports seem constrained and squeezed, use the following pattern:


<div class="container md:max-w-full lg:px-24">

The max-w-full utility makes the element take up as much space as he needs (which is particularly useful for two column layouts, where in md viewports the content would be too loose to place one column, but too large to fit in with the container max-width constraints)

Note: The lg:px-24 viewport utility is optional, it depends on how wide the content of the section is or your space needs.



The :first-child selector is very strict - it only matches if the element is the literal first child of its parent container. When you want to universally target elements that are used a lot (e.g sections), use :first-of-type better. 

:first-of-type matches the first element of that specific type among siblings 



Astro has built-in TypeScript support, that treats all components as TypeScript by default, even when you write plain JavaScript. Is not like there's something wrong with your code when you write plain JavaScript and get flagged a Type error. The errors you mostly see are from your editor's TypeScript language server, not from Astro's build process. 

To completely opt out of TypeScript for your project, open VS Code Command Palette by pressing Ctrl+Shift+P, select Preferences: Open Workspace Settings (JSON) and ad the following code to the file.


{
  "typescript.validate.enable": false
}

Keep in mind that you can freely mix TypeScript and JavaScript in Astro projects—it's completely fine and actually a common practice. Astro processes everything through its TypeScript compiler regardless of whether you write TypeScript or JavaScript. This means that .js and .ts files can coexist in the same project, and that Astro components can contain plain JavaScript or TypeScript synthax.

No mandatory consistency is required either: Some components can use TypeScript features (like type annotations) while others use plain JavaScript



The <hr> tag, called Thematic Break, defines a thematic break in an HTML page (e.g. a shift of topic).

The <hr> element is most often displayed as a horizontal rule that is used to separate content (or define a change) in an HTML page, or also used as a divider. It can be styled if needed.



---ABOUT COMPONENT DATA MANAGEMENT IN ASTRO.JS----

In Astro.js, you use expression syntax (the single curly braces {} ) and template literals to inject data from the frontmatter directly in your HTML, just like in JSX. 

For example:

---
const eyebrow = "WORK WITH THE BEST";
---
<p>{eyebrow}</p>

This works and is a legitimate pattern, especially for static landing pages and one-off components you're not intending to reuse.

But there're different patterns/solutions for different scenarios as well:

1. For components that you'll likely reuse with different content, props are the recommended best practice. You'd then just pass the data via props from the parent component to the child, or in the page where your component is being used.

2. When we're handling data from a list, we use JavaScript's native .map() method within our markup. Let's say we need to generate a number of feature cards within a component, one feature card per each item within a 'const features' array, along with additional information from the feature, like title, image and a URL. 

We would do something like this in our markup:

{features.map((feature) => (
  <div>
    <h3>{feature.heading}</h3>
    <p>{feature.description}</p>
  </div>
))}

You can even perform filtering operations before the mapping, to filter out data in real time before rendering elements. 

This is the equivalent of Vue 3 'v-for' directive. 


3. When we want to display (or not display) something based on a given condition, we use conditionals with ternary:

{isVisible ? <div>Shown</div> : <div>Hidden</div>}

--------------


In Tailwind v4, animations are defined using CSS variables with the pattern --animate-*
You can also link them to user actions, such as hover:

<button class="px-8 transition-transform hover:animate-(--animate-fade-in)">

You can also control parameters of the animation directly from Tailwind, such as duration and delay:

<div class="animate-(--animate-fade-in) delay-300 duration-1000">
  Delayed fade in
</div>



Since you're borrowing themes from Radix UI, and you're not set up in the conventional way, some of the  Tailwind animations defined in the stylesheet just won't work (since they're expecting Radix values). However, the default Tailwind animations will work fine. 

From Shadcn/ui stylesheets, the only animation that will work by default is this one:


animate-(--animate-fade-in)              

The other animations that work without setup are the below (because they're native to Tailwind, you do not even need to declare them):
     
animate-spin                              
animate-pulse                           
animate-ping                              
animate-bounce                      

This means that, when it comes to animations, you're on your own as well.



Working with fonts in Astro + Tailwind projects is fairly straight-forward. Just import the fonts you wish to use at the top of your global.css styles:

@import url("https://fonts.googleapis.com/css2?family=Geist:wght@100..900&display=swap");
@import url("https://fonts.googleapis.com/css2?family=Bebas+Neue&display=swap");


Then, inject the font you want to use as the default into your body via @layer base:

@layer base {
  body {
    @apply bg-background text-foreground font-geist antialiased;
    scrollbar-gutter: stable;

  }
}

This will make Geist the first-choice font throughout your project. 

Any other font you need to use, you'll need to make sure it is imported in global.css first, and then you just have to use any of your predefined variables as a utility class (or create a new one if you do not have it for that specific font)

For example, in an <h1> element:

<h1 class="font-bebasNeue text-3xl">



Astro renders everything as static HTML by default. For React components with animations to work, you need to add a **client directive** to tell Astro to hydrate the component on the client side.

Common directives:
- `client:load` - Hydrates immediately on page load
- `client:visible` - Hydrates when component enters viewport
- `client:idle` - Hydrates after page is idle

The client:* directive is a rendering instruction that tells Astro when and how to hydrate the component on the client-side. 



In development, Vite (Astro's and Vue's build tool) uses unbundled ESM (ES Modules). This means:
✅ Each module is served individually (that's why you see 156+ requests)
✅ Source maps are included for debugging
✅ No minification or tree-shaking
✅ Hot Module Replacement (HMR) code is included
✅ This is intentional for fast dev experience

This is why you see sometimes enormous load sizes when testing on your local environment



Unnused dependencies do NOT affect your build. Astro (and modern bundlers in general) only bundle code that's actually imported and used in your components.

Astro scans your components and only includes code that you explicitly import.

Modern bundlers (Vite, which Astro uses) eliminate dead code:

-Only used exports from libraries are included
-Unused functions are stripped out
-Empty imports are removed entirely

Even if you install a package and is in your node_modules folde (e.g React), these packages won't be added to the build as long as they're not imported in your components (even if they're added to the package.json dependencies, because of tree-shaking)



Be aware of the distinction between IMPORTING and USING/RENDERING. Importing is when you import the file/module/package at the top of your code file. Using/rendering means when you use a component or asset that you imported in the template area of your code file (e.g in Vue <template> or inside the Component Template in Astro.js)



Be careful when selecting files in VS Code to delete. You sometimes have a file already selected (that you do no intend to delete, but it's include in the selection) and, without being aware, delete it as well. 