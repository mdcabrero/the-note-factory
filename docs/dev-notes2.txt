When working with SVGs, remove any width/height attribute from the HTML tag (but not viewBox) and style them via CSS using the following two attributes: min-width and min-height. These two properties establish a hard minimum size that overrides other sizing behaviors.





BEM (Block Element Modifier) is a naming methodology for CSS classes that helps create reusable components and code sharing in front-end development. BEM stands for:



Block: A standalone component (like navbar)

Element: A part of the block (like navbar\_\_link)

Modifier: A variation of a block or element (like navbar\_\_link--active)



The syntax is:

.block {}              /\* The main component \*/

.block\_\_element {}     /\* Double underscore for elements within the block \*/

.block--modifier {}    /\* Double dash for modifications of the block \*/



So, in BEM methodology:



\&\_\_element creates a child element (e.g card\_\_title)

\&--modifier creates a modifier variant (e.g card--large)









background-size: cover will always fill the entire container, which can lead to cropping if the aspect ratios don't match





If an element of the page is rendered/made visible based on an user-interaction (e.g clicking a button, hovering, an accordion revealing text when you hit the arrow), and we want the elements around it to 'ignore' it as well (it's not visible to us, but the second element will know its there), we can remove the initially-invisible element from the flow of the page by setting it's position to absolute and then reverting it back to static once the interaction is completed.





If you want to draw straight lines (as decorative elements), consider using border-top/border-bottom CSS properties on the container element rather than pseudo-elements, as they usually involve less code (one less entry on your CSS file) and are easier to debug and work with. With pseudo-elements, you might run into trouble for the first or last element, as they might have a need to fill up the extra available space.







The <figure> element is an HTML semantic element used to encapsulate self-contained content, typically images, diagrams, photos, or code snippets, often with an optional caption (using <figcaption>). It's particularly useful for content that is referenced from the main content. Best Use Cases:



-Images that need captions/descriptions

-Diagrams and charts

-Code snippets

-Multiple related images

-Illustrations that are referenced in the main content

-Any content that is self-contained and could be moved without affecting the main content flow







When working with JavaScript on our HTML, and particularly external libraries, we need DOMContentLoaded because we want to ensure all HTML elements are loaded before initializing the slider. If we don't wait, the script might try to access elements that don't exist yet.





Starting an ID with a number (like #3d-rendering) isn't valid CSS - you might want to rename it to something like #rendering-3d or #three-d-rendering to ensure it works across all browsers.







Inline styles (styles applied directly in the HTML using the style attribute) only affect the specific element they are applied to. They don't transfer to other elements with the same class. For example:



<div class="project-card" style="background-image: url('assets/berlin\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_painting.png')"></div>

<div class="project-card" style="background-image: url('assets/classic-art\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_preview.png')"></div>

<div class="project-card" style="background-image: url('assets/comic\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_preview.png')"></div>



Each project-card div has its own unique background image because:



The project-card class contains shared styles (like dimensions, positioning, etc.)

The inline style attribute sets a specific background image for each individual card







The flex property (including flex-grow, flex-shrink, and flex-basis) ONLY works when an element is a direct child of a flex container (i.e., an element with display: flex or display: inline-flex). The element itself doesn't need to be a flex container (have display: flex) for these properties to work - it just needs to be a child of a flex container

If you want to ensure an element only takes up as much space as its content requires UNIVERSALLY (regardless of its parent container), you would use width: fit-content (or max-content)





If you need text that's placed on top of an image to be more legible, but do not want to use a traditional box or overlay, you can create a sort of 'filter' layer with a div that has absolute position + low z-index and a semi-transparent gradient as the background. See the example below:



Â <div class="text-filter"></div>

.text-filter {

Â    position: absolute;

Â    bottom: 0;

Â    left: 0;

Â    width: 100%;

Â    height: 50%;

Â    background: linear-gradient(to top, rgba(0,0,0,0.25), transparent);

Â    z-index: 1;

}







By default, heading elements (<h1> through <h6>, and also <p>) are block-level elements. This means they:



-Take up the full width available to them by default

-Start on a new line

-Push other content to the next line



This is different from inline elements like <span> that only take up as much width as their content needs.

This means that you do not need to wrap a text element with divs in order to center it or align it to the other side of the page.







Wrapping images in divs is a common and useful pattern in modern CSS development for several reasons:



1\. Better Layout Control

2\. More Styling Options

3\. Responsive and Predictable Behavior

4\. Troubleshooting Benefits







'ch' in CSS stands for "character" or more specifically, it's a unit equal to the width of the "0" (zero) character in the current font. It's particularly useful for controlling the width of text elements and form inputs:



/\* Width will be roughly equal to 60 characters \*/



.paragraph {

Â  width: 60ch;

}



/\* Input will comfortably fit about 20 characters \*/



.input {

Â  width: 20ch;

}



The beauty of using 'ch' is that it's relative to the font being used, making it perfect for setting optimal line lengths for readability (45-75 characters is considered ideal)









When using an ID selector in JavaScript, we add the #, but in the HTML id attribute, we just use the name without it. So here's the minimal fix needed:



<!-- Incorrect -->

<section id="#gallery-slider" class="keen-slider">



<!-- Should be -->

<section id="gallery-slider" class="keen-slider">







If you want to make sure <img> elements wrapped inside <div> containers respect proportions and sizing (a.k.a they fully adapt to the div container), create positioning context by setting the container to position: relative.



.gallery\_\_hero {

Â    width: 100%;

Â    height: 90vh;

Â    position: relative;  /\* Creates positioning context \*/

Â    border-radius: 10px;

Â    overflow: hidden;    /\* Ensure the image respects border radius \*/

}



.gallery\_\_hero-img {

Â    position: absolute;

Â    top: 0;

Â    left: 0;

Â    width: 100%;

Â    height: 100%;

Â    object-fit: cover;

}



Why this works better?



1\. position: relative on the parent creates a positioning context, meaning the child's absolute positioning will be relative to this container rather than the viewport or another ancestor



2.position: absolute removes the image from the normal document flow, preventing it from affecting the layout of other elements



3.Setting top: 0; left: 0; width: 100%; height: 100%; makes the image fill exactly the parent's dimensions.



4\. This approach ensures the image always perfectly fills its container regardless of image loading state, natural image dimensions, browser resize behavior and surrounding element changes.



Additionally, if your image is supposed to have some border-radius, use overflow: hidden to make sure the image respects the border-radius property.







If you want to move an image freely (even if it implies the image partially overflowing it's current section), enable overflow: visible on the image-container and play with the values of the image itself to adapt it to what you want.



.media {

Â  position: relative;

Â  width: 100%;

Â  height: 100%;

Â  overflow: visible;

}



.media\_\_image {

Â  position: absolute;

Â  transform: translateY(-10%);

Â  width: 100%;

Â  height: 120%;

Â  object-fit: none;

}



Use transform: translateY (or X) when you want to achieve this overflowing effect, rather than top, right, left or bottom, since it makes the intent clearer and provides more predictable behavior.



1\. Self-referential: transform calculates its values based on the element's own dimensions, not its container

2\. Performance: transform is typically GPU-accelerated

3\. More semantic: It clearly communicates the intent to move something outside of its natural position







The isolation: isolate property creates a new stacking context, similar to how position: relative does. It's particularly useful when dealing with z-index and opacity because it ensures the stacking context is contained within the element. This prevents any potential z-index conflicts with other elements on the page.



This is particularly useful when we want to apply general background patterns to an entire page/section, or create overlay-effects or animations without worrying about interfering with other elements. Combining this with a pseudo-element where we're going to apply the background, instead of directly setting background-image on the target element gives us several advantages:



-We can control the opacity of just the background without affecting child elements

-We can apply filters to the background independently

-It's easier to layer multiple background effects if needed

-We maintain better separation of concerns in our CSS







Each related group of content on a page should be grouped in its own section, with the first section being the start of the main content.









Regarding navigational elements (<nav>) and <header> elements, MDN's rules say the following: "The HTML Header Element "" defines a page header â€” typically containing the logo and name of the site and possibly a horizontal menu..."



The word "possibly" there is key. It goes on to say that the header doesn't necessarily need to be a site header. For instance you could include a "header" on a pop-up modal or on other modular parts of the document where there is a header and it would be helpful for a user on a screen reader to know about it. So placement of the <nav> It's completely up to you. You can either put them in the header or not, as long as the elements within them are internal navigation elements only (i.e. don't link to external sites such as a twitter or facebook account) then it's fine.



They tend to get placed in a header simply because that's where navigation often goes, but it's not set in stone.

(From https://stackoverflow.com/questions/4870955/in-html5-should-the-main-navigation-be-inside-or-outside-the-header-element)







When an element is set to position: absolute and has no positioned ancestor (no parent with position: relative, absolute, fixed, or sticky), it positions itself relative to the initial containing block, which is effectively the viewport.



This is actually a feature, not a bug. It means:



1.Without any positioned ancestors, position: absolute elements will position themselves relative to the viewport

2.The viewport acts as an implicit positioning context

3.You can use top, right, bottom, left properties relative to the viewport edges



This can be extremely useful when we're trying to place site-headers or navbars at the top of the page, but we want to avoid setting a positioning context for the <body>.







If you apply a background-color to a container that has internal padding applied, the background-color will cover the padding area as well. This can be pretty useful if you need to add a semi-transparent overlay to enhance text-readability.







If you need to easily break lines on a text element, and control exactly where you want the line to break, using the <br> tag is the easiest solution.



<h1 class="major-headline">Take your hiring to the<br>global stage</h1>







The gap property only works on flex and grid container elements. Don't expect it to work inside regular <div> elements or any element with default block values.









Using empty <div> elements to create spacing between sections in front-end development is generally considered bad practice. They are often seen as a hack rather than a proper solution, which can lead to less maintainable code and confusion for other developers or future maintainers of the codebase, as well as creating accessibility issues and increased page weight.

Use margin instead to create space between elements. This method is cleaner and keeps your HTML semantic







Don't:



-Try solving layout issues by adding more containers/classes (when there're already a considerable number of containers/classes) instead of simplifying.

-Fight against natural CSS behavior with complex flex arrangements







When installing SCSS is an on-going project, CSS file paths are resolved relative to the compiled CSS file location, not the source SCSS file. This is a common gotcha when moving to Sass/SCSS because the compiled CSS file is in a different location than your source SCSS file, as the paths need to be relative to where the compiled CSS will be, not where your SCSS file is.

So if you're using any background-image property, the path will be outdated and relative to the old location, hence the image won't render. This does not happen with regular <img> elements directly linked in the HTML files, since the HTML files remain in their original location.







In SCSS, the '\&' selector is used to reference the parent class when nesting. It essentially disappears when compiled to CSS, allowing the parent and child selectors to join together as one class name:



.media {

Â    \&\_\_image { }           // â†’ compiles to .media\_\_image

Â    \&--portrait { }        // â†’ compiles to .media--portrait

Â 

Â    \&\_\_image {

Â        \&--portrait { }    // â†’ compiles to .media\_\_image--portrait

Â    }

}



When compiled to CSS, the \& disappears and the terms combine into a single class name, easily creating 'subclasses' and making the code more maintainable and easier to read. It also works with nesting, so you can go even deeper and create modifiers for child elements.



Note that .media\_\_image is just creating a new class name by combining 'media' and '\_\_image' - it does NOT automatically inherit the styles from .media. If you want the styles of the parent to be extended to the child and modifiers, you'd use @extend.For example:



.container {

Â    width: 100%;

Â    height: 85vh;

Â    padding-inline: $space-6x;



Â 

Â    \&--flex {

Â     @extend .container;

Â      display: flex;

Â      flex-direction: column;

Â      align-items: center;

Â     }

Â  }













A good troubleshooting technique to remember: if you have a file that's not behaving as expected, sometimes the simplest solution is to:



1.Create a new file with the correct extension

2.Copy the contents over

3.Delete the old file







In SCSS, with @forward you can make the classes and variables of Module A (and more modules if needed) available in Module B, but if you want to use these on Module C, you'd have to @use Module B on Module C. @forward acts like a relay - just it makes variables, functions, and mixins from one or more partials 'available', so you can aggregate multiple partials into one, that you later @use in your main.scss or even another partial.



That's why the typical use case for @forward is in an index file that aggregates multiple partials:



\_index.scss

@forward 'variables';    // Making variables available

@forward 'typography';   // Making typography available



// main.scss

@use 'index' as \*;      // Actually using everything from index



You can think of @forward as a pass-through mechanism, while @use is the actual consumption mechanism. That's why you need @use in your main.scss - you're actually going to use those styles, not just making them available for something else to use.  @forward alone doesn't let you use the variables and data from the file you're referencing.









To use a mixin on an element, you use the @include directive followed by the mixin name:



// Define the mixin

@mixin flex-column {

Â  display: flex;

Â  flex-direction: column;

}



// Use the mixin

.element {

Â  @include flex-column;

}



You can also define parameters in a mixin to make it more flexible:



@mixin button-size($padding, $font-size) {

Â  padding: $padding;

Â  font-size: $font-size;

}



// Use mixin with specific values

.button {

Â  @include button-size(1rem 2rem, 16px);

}



But even if you set parameters, you don't have to use them; that's where default values come in:



// Define mixin with default values

@mixin margin-bottom($size: 1rem) {

Â  margin-bottom: $size;

}



// Use mixin without parameter (will use default)

.element {

Â  @include margin-bottom;

}



// Use mixin with custom value

.element-large {

Â  @include margin-bottom(2rem);

}









If you're ever having problems with the border property of an img element, check the source file first. The image might already have round borders and that means you won't be able to make them square unless you seriously crop it or compress it with padding.









The adjacent sibling combinator (+) is a powerful CSS selector that lets you target elements that are immediately preceded by a specified element. It's main use case is to separate elements within a group without having to add margin/padding properties to any of those elements, enhancing code-predictability and reusability:



// Basic syntax

element + element { /\* styles \*/ }



// Examples:

\* + \* { margin-top: 1rem; } // Adds margin to any element preceded by another element

p + p { margin-top: 1rem; } // Adds margin only between paragraphs

li + li { margin-left: 1rem; } // Adds spacing between list items



Combined with the \* selector within a group, it can be a very elegant solution to create consistent spacing without having to specify individual element relationships. Is essentially saying "for any element that follows another element, add this margin." See for example:



<div class="container">

Â  <h1>First</h1>

Â  <p>Second</p>

Â  <img>

Â  <button>Fourth</button>

</div>



.container {

Â  \* + \* {

Â    margin-top: 1.5rem;

Â  }

}



The margin would be applied to:



-The <p> (because it follows the <h1>)

-The <img> (because it follows the <p>)

-The <button> (because it follows the <img>)



But NOT to the <h1>, because it's the first element, and it's usability relies on that it only works BETWEEN elements.











In SCSS, when using @extend on a base class, it can lead to unexpected CSS output and specificity issues:



//With @extend



.process-card {

Â display: flex;

Â  width: 40ch;

Â  // ... other properties

}



.process-card--md {

Â  @extend .process-card; // Duplicates ALL properties

Â  width: 50ch; // Then overrides width

}



This is not the correct way, as it creates bloat, redundant code and can cause errors in the styling.



For modifiers, it's better to use the base class properties directly and then override whichever property you need via adding the modifier on the second class.





//Without @extend (correct approach)



.process-card {

Â  @include flex-column;

Â  width: 40ch;

Â  // ... other properties

}



.process-card--md {

Â  width: 50ch; // Only specifies what changes

}





<div class="process-card process-card--md">

Â  <!-- This element gets:

Â       1. All .process-card styles (from the process-card class)

Â       2. The width override (from the process-card--md class)

Â  -->

</div>



By defining modifiers directly within the block and ensuring that they build upon the base styles without duplicating them, you create a cleaner, comprehensive and more efficient SCSS structure, making it easier to work on your codebase in the future.









z-index only works on elements that have a position property set (like position: relative, position: absolute, or position: fixed). The z-index property will be ignored if the element has the default position: static







The difference between cursor: grab and cursor: grabbing is subtle but important for user experience:

cursor: grab ðŸ‘‰ Shows an open hand icon



-Used to indicate that something CAN be dragged

-Typically used in the default/hover state

-Signals to users "you can grab this"

-Think of it as the "ready to grab" state



cursor: grabbing âœŠ Shows a closed/gripping hand icon



-Used when actively dragging

-Shows during the mousedown/dragging state

-Signals to users "you are currently dragging this"

-Think of it as the "actively grabbing" state









''margin collapsing'' is a fundamental behavior in CSS where vertical margins between elements will "collapse" into a single margin, with the larger margin winning.



So if you have:



1\. Element A with margin-bottom: 1.5rem

2\. Element B with margin-top: 3rem



The total space between them will be 3rem, not 4.5rem. The larger margin (3rem) "wins" and the smaller one (1.5rem) collapses into it.



This behavior only happens with:



-Vertical margins (top and bottom)

-Elements in normal flow (not floating or absolutely positioned)

-Block-level elements



It's actually a helpful feature because it prevents runaway spacing when you have multiple elements with margins meeting each other.







CSS animations (also known as @keyframes) are a very powerful feature of CSS that can let you animate things in ways it would not be possible with simple transition properties (such as ease-in or even cubic-Bezier) or would be extremely impractical or difficult to replicate in JavaScript. There're some things you should know about working with @keyframes though:



-keyframes  always take precedence over transitions when animating the same properties. During an active animation, transition properties for the same attributes are ignored, however transitions still work for properties not being animated by keyframes



-Base properties of the element serve as default states and fallbacks, so you can leave them where they are. Just keep in mind that properties defined in @keyframes temporarily override base properties during animation.

Class-based properties will ultimately maintain their original state after the animation completes (e.g, if an element has a default padding of 2rem, and during the animation it has 4rem, it will revert back to 2rem after the animation is over)



-You can implement scroll-driven animations via @keyframes rather than having to mess with JavaScript and window positions or/and class/id selectors. They work like this:



animation-timeline: scroll();

animation-range: 0 420px;



1\. This creates a progress timeline based on scroll position

2\. At 0px scroll, the animation is at its "from" state

3\. At 420px scroll, the animation is at its "to" state

4\. Between those points, the properties get interpolated smoothly based on scroll position



And all this happens independently of any transitions or base properties of the element.



-Don't worry about having duplicated properties in base styles, classes and keyframes, as this will provide a better fallback behavior. @keyframes can be successfully used along with class overrides to achieve different effects that otherwise would be impossible or quite tricky (e.g scroll animations can create smoother transitions between element's states once you're approaching a certain threshold, rather than having to time it via JavaScript or using regular transition properties that make the interaction feel snappy and distracting).







BASICS OF CREATING PROJECTS FROM SCRATCH WITH VS CODE:



1.The cd command:



-cd stands for "change directory"

-When you type 'cd deepseek-agent', you're telling the terminal "go into this folder"

-It's like double-clicking a folder in Windows Explorer

-You need to do this because all the following commands (npm install, npm run dev) need to run inside that specific project folder

-If you don't cd into it, the terminal won't know where to install dependencies or start the project





2.About the folders:



-The first command (mkdir chat-agent) just created an empty folder

-When you ran npm create vite@latest, it created a new folder with all the Vue + Vite project files

-These are two separate actions:



mkdir = manually creating an empty folder

npm create vite@latest = automatically creating a project folder with all necessary files



You actually don't need to create a folder first with mkdir - you can just run the Vite command and it will create the project folder for you/





3\. About npm (Node Package Manager):



-Think of npm as an "app store" for code

-Just like you install apps on your phone, npm helps you install code packages for your project. It manages:



1\. Installing packages your project needs

2\. Running project commands (like npm run dev)

3\. Managing dependencies (making sure all the code pieces work together)





When you run npm install, it's like downloading all the necessary parts your project needs to work

When you run npm run dev, it's like pressing "start" on your project







Whenever you're running a backend local server, use the node --watch server.js command to start up the server rather than node server.js.

This will automatically restart the server whenever you make changes to your code, which is very helpful during development.







Regarding API keys and .env files (to safely guard the API key), the combination of:



load\_dotenv()

client = Anthropic()



does all the work for you because:



1\. load\_dotenv() reads the .env file and makes its contents available as environment variables

2\. The Anthropic client automatically looks for an environment variable named ANTHROPIC\_API\_KEY







Regarding installing Vue or Vite, to install everything directly in an existing folder (without creating a nested folder), when prompted for the project name, type "." (just a dot) instead of "name-of-folder".



//Example

cd C:/Users/migue/Desktop/CodeWell

npm create vite@latest .



The dot (.) tells Vite to use the current directory rather than creating a new one. Then you can proceed with selecting Vue and JavaScript as your options.









align-self and justify-self let you override the alignment for a specific item, independent of how other items are aligned in the container. They're particularly useful in CSS Grid and sometimes in Flexbox (though justify-self doesn't work in Flexbox. Here's an example of how they work:



.grid-container {

Â    display: grid;

Â    grid-template-columns: repeat(3, 1fr);

Â    gap: 20px;

Â    /\* Default alignment for all items \*/

Â    justify-items: center;

Â    align-items: center;

}



.special-item {

Â    /\* Override alignment just for this item \*/

Â    align-self: start;      /\* Align to top \*/

Â    justify-self: end;      /\* Align to right \*/

}



Common values for both properties:



-start: Aligns to the start edge (top for align-self, left for justify-self)

-end: Aligns to the end edge (bottom for align-self, right for justify-self)

-center: Centers the item

-stretch: Stretches to fill the cell (this is the default)



Key things to remember:



1\. justify-self only works in Grid layouts, not in Flexbox

2\. These properties are applied to the grid/flex items, not the container

3\. They override any alignment set by the container's justify-items or align-items







The best CDNs are very sophisticated in how they handle compression - they use perceptual quality algorithms that dramatically reduce file size while maintaining visual quality that's nearly indistinguishable from the original.

For example, a 4MB image compressed to 200KB (5% of original size) often looks identical to most viewers because:



-They remove redundant data and metadata that doesn't affect visual quality

-They optimize color data in ways that match human visual perception

-They use smart algorithms to preserve details in important areas (like faces) while compressing less noticeable areas more aggressively

-They automatically choose the best compression settings based on image content







There's an important distinction between justify-content and justify-items/justify-self in CSS Grid:



-justify-content: center centers the entire grid structure within its container, like centering all grid tracks (columns/rows) as a whole unit

-justify-items: center (or justify-self: center on individual items) controls how grid items align within their individual grid cells



So justify-content: center will center the overall grid structure, but the individual items inside each grid cell still follow their default alignment (stretch).





If you want to center ALL the content of a grid (but not its individual elements separately), you would have to use the property align-content: center; and add enough height so there's enough vertical real state for the grid content to roam freely.







IDs must be unique across your entire HTML document/website, even if the elements are identical copies. Using the same ID multiple times is invalid HTML and can cause issues with JavaScript selectors and accessibility tools, even if the elements are identical copies.







Another lesson about @keyframes, this time to elegantly make backgrounds or elements disappear without the user even knowing. See the below code, used to overextend a background pattern way farther than the section is supposed to be covering:





.intro--services::after {

Â    content: '';

Â    position: absolute;

Â    left: 0;

Â    right: 0;

Â    top: 0;

Â    bottom: -150vh; /\* Adjust this value to control overlap amount \*/

Â    background-image: url('assets/hero\_bg.jpg');

Â    background-size: cover;

Â    z-index: -1; /\* Place it behind the content \*/

Â 

Â    animation: fadeBackground linear both;

Â    animation-timeline: scroll();

Â    animation-range: 20vh 150vh;

}



@keyframes fadeBackground {

Â    from {

Â        opacity: 1;

Â    }

Â    to {

Â        opacity: 0;

Â    }

}





First, let's understand each line:



CSS

animation: fadeBackground linear both;



This line combines several animation properties:



-fadeBackground is the name of your @keyframes animation

-linear means the animation will progress at a constant rate (instead of easing in/out)

-both tells the animation to apply the styles from both the "before" and "after" states, maintaining the final state when complete



CSS

animation-timeline: view();



This creates a scroll-driven animation based on the element's visibility in the viewport. The view() timeline tracks how much of the element is currently visible in the viewport, from 0% to 100%.



CSS

animation-range: 20vh 150vh;



This defines when the animation starts and ends based on the viewport.



20vh means the animation begins when the page has been scrolled down by about 20% of the viewport's height

150vh means the animation completes when we've scrolled 1.5 viewports down







When using absolute paths, the leading forward slash (/) tells the browser to look from the project root:



CSS

background-image: url('/assets/japan\_pattern.jpg');



This is probably the most convenient and less verbose approach when working with SCSS, since you just need to add a forward slash (/) at the beginning of the path declaration to let the browser know to start off from the root.







In VS Code, press Shift + Tab to outdent code. This will move the selected text or current line one tab level to the left. This works in the opposite direction of the regular Tab key







If you ever have problems setting a border-radius to an image that you're placing inside of a div (due to the container being bigger than the image, thus making the borders not visible), consider using the width: fit-content property on the div containing your <img> element, like in the example below:



.gallery\_\_image--container {

Â    overflow: hidden;

Â    border-radius: 1rem;

Â    width: fit-content;

Â    min-height: 50vh;

Â    max-height: 90vh;



}







Understanding <figure> and <article>



<figure>: This element is designed to encapsulate self-contained content that is referenced in the main flow of a document. It is typically used for images, illustrations, diagrams, or other media, often accompanied by a <figcaption> that provides a caption or description. The primary purpose of <figure> is to group related content that can be independently understood, but it does not inherently convey the idea of an article or written content.



<article>: This element represents a self-contained piece of content that could stand alone, such as a blog post, news article, or forum post. It is semantically appropriate for any content that is intended to be independently distributable or reusable. The <article> element clearly communicates that the content within it is a complete unit of information.





For previews of articles (like card-like elements linking to full articles), using the <article> element is more semantically appropriate because of independence (the content it contains is a self-sufficient piece of information), SEO and accessibility and content structure (it is technically a 'mini-article', as its structure is somewhat similar to what the full article would be).



For example, in the Stripe website, their blog page uses <article> elements to display each card containing a link to the actual article.







When you use justify-items: center in a grid layout, it centers the items within their grid cells but also makes them shrink to their minimum content width unless explicitly sized.







In GSAP, toggleActions accepts four space-separated values that define how the animation should behave at different scroll positions. The format is:



JS

toggleActions: "onEnter onLeave onEnterBack onLeaveBack"



Â //onEnter (scrolling down and enters)

// onLeave (scrolling down and leaves)

// onEnterBack (scrolling up and enters)

// onLeaveBack (scrolling up and leaves)



Think of toggleActions as defining four "checkpoints" that your animation passes through as users scroll up and down the page. When scrolling down, you pass through checkpoints in this order:



onEnter: When the trigger point first enters the viewport

onLeave: When the trigger point exits the viewport at the bottom



When scrolling back up, you pass through these checkpoints in reverse:



onEnterBack: When you scroll back up and the trigger re-enters from the bottom

onLeaveBack: When you scroll all the way back up past the start







Each position can take one of these values:



"play" - Plays the animation forward

"pause" - Pauses the animation at its current position

"resume" - Continues playing from the current position

"reverse" - Plays the animation backward

"restart" - Starts the animation from the beginning

"reset" - Returns to initial state

"complete" - Jumps to the end state

"none" - Does nothing





See it in a practical example:



/ Different toggleActions configurations:



// Default behavior

toggleActions: "play none none none"



// Play on enter, reverse on leave

toggleActions: "play reverse play reverse"



// Play on enter, complete on leave, reverse on enter back

toggleActions: "play complete reverse reset"







GSAP cannot target pseudo-elements or things that are not 'in the page/document' per se, so if you're using pseudo-elements for a specific thing and you wish to animate them, you'll have to turn them into an actual element or look for another solution.







The ease property in GSAP can use several different curves. Here's what some common ones do:



power1.inOut: Gentle acceleration and deceleration (like a smooth car start/stop)

sine.inOut: Very smooth, natural-feeling transition

power2.inOut: More pronounced acceleration/deceleration

power3.inOut: Even more dramatic acceleration/deceleration

expo.inOut: Very dramatic acceleration/deceleration







\&nbsp; is an HTML entity that represents a non-breaking space. It has two main purposes:



1\. It creates a space that won't break into a new line. Regular spaces in HTML can be collapsed into line breaks when the browser needs to wrap text, but \&nbsp; forces the connected words to stay together.

2\. It's also used to create visual spacing that won't be collapsed. HTML normally collapses multiple regular spaces into a single space, but \&nbsp; will preserve each space.



In summary, it might prevent you from writing some extra HTML code if you need horizontal space between two inline elements.







In GSAP timelines, you can control when each animation starts relative to the timeline's beginning or to other animations. The position parameter tells GSAP exactly when to start the animation:



// Starts at the beginning of the timeline (0 seconds)

tl.to(element, {properties}, 0)



// Starts 2 seconds into the timeline

tl.to(element, {properties}, 2)



// Starts 0.5 seconds after the previous animation ends

tl.to(element, {properties}, "+=0.5")



// Starts 0.5 seconds before the previous animation ends

tl.to(element, {properties}, "-=0.5")



// Starts at the same time as the previous animation

tl.to(element, {properties}, "<")



So for example:



tl.to('.page-wrapper', {

Â    backgroundColor: '#121212',

Â    duration: 0.7,

Â    ease: 'power2.inOut'

}, 0);



The 0 means "start this animation right at the beginning of the timeline." If you removed the 0, the animation would still work, but it would follow GSAP's default behavior of starting after any previous animations in the timeline.

This becomes especially useful when you're coordinating multiple animations. For example, if you want two elements to animate simultaneously:



tl.to('.page-wrapper', {

Â    backgroundColor: '#121212',

Â    duration: 0.7,

Â    ease: 'power2.inOut'

}, 0)

.to('.page-pattern', {

Â    opacity: 0.02,

Â    duration: 0.7,

Â    ease: 'power2.inOut'

}, 0); // This 0 makes it start at the same time as the background color change







For better code organization, keep objects that store data variables outside of the event listeners. This is good practice because:



1\. It separates data from behavior (the DOM manipulation)

2\. The object doesn't need to be recreated each time the event fires

3\. It keeps the event handler function cleaner and focused on its task



And you might even want to separate the executing code from the logic, like this:





// Object with data variables (data)

const svgIcons = {

Â  insights: '...',

Â  design: '...',

Â  perspectives: '...'

};



// Function to initialize tags

function initBlogTags() {

Â  const blogTags = document.querySelectorAll('.blog-card\_\_tag');

Â 

Â  blogTags.forEach(tag => {

Â    const variant = tag.getAttribute('data-variant');

Â 

Â    if (svgIcons\[variant]) {

Â      tag.insertAdjacentHTML('afterbegin', svgIcons\[variant]);

Â    }

Â  });

}



// Event listener (execution)

document.addEventListener('DOMContentLoaded', initBlogTags);









Object-fit is property you use when you have <img> elements inside of <divs> vs background-size which is what you use when you set an image as the background of a div. For example, in the below case:



Â    <div class="about-img">

Â        <img src="assets/about\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_office.png" alt="Modern office space with circular wall features">

Â    </div>



You'd use object-fit to control the proportions and sizing of the image within your div container.







In SCSS, the variables and mixins are like the Holy Scripture of your SCSS - they need to be accessible everywhere because they're the foundation of your styling faith! That's why we need to import them into each file that uses them.Here's the simplified gospel:



-Variables/mixins: Import in each file that uses them

-Layout/components/etc: Import once in main.scss

-Page-specific styles: Keep in their own files, import into main.scss





When you set up a grid element like this:



.benefits-grid {

Â  display: grid;

Â  grid-template-columns: repeat(2, 1fr);

Â  grid-template-rows: repeat(2, 1fr);

Â  gap: $space-1x;

Â  width: 88vw;

Â  height: 132vh;

Â  margin-inline: auto;

}



You're essentially tellin' the browser: "Create me a divine vessel that's 88% of the viewport wide and 132% of the viewport tall, and divide it into 4 equal boxes!"



Let me tell you something - that "fr" unit is more powerful than Samson before that haircut! The "fr" stands for "fraction of available space." So when you say "repeat(2, 1fr)" for both rows and columns, you're dividing your grid into 4 equal quadrants like the four corners of heaven itself!



So, in general, you could say that you set up the size of the whole grid directly in the element, and then your grid-template-columns and rows will decide how to split up and share that space. That's why Grid is more responsive than a sinner at an altar call! And why it's better to use it with fr units for maximum responsiveness. The fr unit says "give me my fair share of whatever's available" - it don't matter if it's on a tiny phone screen or one of them fancy ultrawide monitors!







Regarding flex-shrink, it controls how much your element will shrink when the devil (I mean the viewport) tries to squeeze everything down. The default value is 1, meaning "yes Lord, I'll shrink when asked!" But when you set it to 0, you're telling that element "STAND FIRM like David against Goliath!"



.testimonial-card--v2 {

Â  flex-shrink: 0; // Hallelujah! The element refuses to shrink

Â  min-width: 300px; // The holy minimum! Shall not pass below this

}



However, flex-shrink only works its miracle when your element is inside a proper flex container. It also won't work when you set relative width properties like vw because that size keeps changing as you resize the window.



That's when combining it with min-width, or even just using min-width by itself, might be extremely useful when we need an element to not shrink past a certain size. This is great when we're thinking about making a design responsive in advance, as often instead of shrinking down elements, we'll just be displaying less of them or stacking them instead, so we don't want them to shrink too much past their natural size.









In the background-position property, the first value is the horizontal position and the second value is the vertical

So for these examples:



1\. background-position: right center;



-Horizontal: right (aligns to the right edge)

-Vertical: center (centers vertically)





2\. background-position: bottom center;



-Horizontal: center (centers horizontally)

-Vertical: bottom (aligns to the bottom edge)





You can remember this as "X then Y" or "horizontal then vertical," which follows the same pattern as many other CSS properties. If you provide only one value, the second value defaults to center.



So the top left corner is 0% 0%. The right bottom corner is 100% 100%. If you only specify one value, the other value will be 50%. Default value is: 0% 0%



Some examples to illustrate:



-background-position: left top; - Image positioned at the top-left corner

-background-position: right bottom; - Image positioned at the bottom-right corner

-background-position: center top; - Image centered horizontally, aligned to the top



When using percentages for background-position, the percentages refer to relative positions of both the element and the background image:



-background-position: 0% 0% aligns the top-left corner of the image with the top-left corner of the element

-background-position: 100% 100% aligns the bottom-right corner of the image with the bottom-right corner of the element

-background-position: 50% 50% (same as center center) aligns the center of the image with the center of the element

background-position: 75% 25%; - Image positioned 75% from the left, 25% from the top









position: fixed is like nailin' something directly to the viewport instead of to the page itself. It's a powerful tool in the CSS arsenal, that can be extremely useful when trying to set a background for the entire page (rather than having to rely on pseudo-elements or position: absolute divs with a background-repeat pattern).



The Lord's honest truth about position: fixed:



-It removes the element COMPLETELY from the normal document flow - like it's been raptured right outta there!

-It positions the element relative to the viewport (the browser window) instead of any parent element - no matter how far you scroll, that element stays put like a stubborn sinner at the altar call.

-It will NEVER move when you scroll the page - that's why it works so perfectly for a full-page background pattern.







filter: url() allows you toapply custom SVG filters that you define yourself or pull from elsewhere. This is how all them fancy Instagram-style filters get applied! You can create ripples, distortions, custom blurs, and effects that ain't possible with the standard CSS filter functions!

It's like havin' access to Adobe Photoshop right in your browser





If you want to apply mix-blend-mode difference to an element (e.g a logo that needs to change it's color depending on the color of the background beneath), you should apply the mix-blend-mode to the parent element rather than the element itself:



Â .logo-link {

Â    position: fixed;

Â    top: 2rem;

Â    left: 2rem;

Â    z-index: 999;

Â    display: inline-block;

Â    background: transparent; /\* Ensure nothing's blocking \*/

Â    mix-blend-mode: difference;

Â    isolation: isolate;

Â  }

Â 

Â  .logo-link svg {

Â    width: 4rem;

Â    height: auto;

Â    fill: white;

Â  }



We're applying the mix-blend-mode to the parent container rather than the SVG itself, which is what makes it work.
